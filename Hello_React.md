# 初めに
ReactみたいなフロントエンドFWって難しいよね。  
とくにメタ的な部分が。  

Nodeが必要だったり、複数のパッケージマネージャー、プロジェクト作成用ツール、謎のディレクトリたち（node_modules, package.json, yarn.lock)などなど

ただでさえたくさん要素がうえに各種ツールの栄枯盛衰もあるので、混乱しがち。

# なぜフロントエンドの開発でバックエンド用のNodeが必要なのか
- パフォーマンス最適化のためにJavaScriptやCSSファイルを少数のファイルにまとめる（＝バンドル）
- 新しいバージョンのJavaScriptやAltJSのコードを古いバージョンのJavaScriptコンパイルして、古いブラウザでも動作可能にする
- 開発環境においてブラウザにローカルファイルを直接読み込ませるのではなく、ローカルに開発用のアプリケーションサーバを稼働させることで、動作を検証しやすくし開発の効率を高める
- テストツールを用いてユニットテストやE2Eテストを記述・実行する
- ソースコードの静的解析や自動生計を行う

# nodeコマンドの使い方
コマンドラインで`python`コマンドを実行するとREPLが実行できるように、`node`と実行することでREPLが起動できる。  
このREPLが割りと高性能らしく、REPL内で複数のコマンドを使用できたり、コマンド保管してくれたりする。  

コマンドの一覧は`.help`で確認可能。  
`.load`コマンドが便利で、ファイルを指定することで簡単に指定したファイル内の関数・メソッドなどが呼び出せる。
```
> .load ファイル名
```

# viteでプロジェクトを作成する
## vite（ヴィート）とは
`vite`は、`Vue.js`の開発者（Evan You氏）によって作られたビルドツール。  

`Vue.js`だけでなく`React`のビルドもサポートしている。

## viteがやってくれること
Reactでそれなりの規模のアプリケーションを作成する場合には、いろんな機能が必要で、
- 最新仕様のJS
- JSXを古いブラウザでも実行可能に変換するためのコンパイラ
- JS及びCSSをひとつにまとめminifyするためのバンドラ

などなど  
またこれらを導入した上で、それらが連携して動作するように複雑な設定を行う必要がある。

そのため、Reactのアプリケーションプロジェクトを作成・運用するためのツールが公式やサードパーティから提供されている。  
その一つが`vite`。 

他にも
- Webpack
- create-react-app
- esbuild

などが存在する

# viteでプロジェクトを作成する
コマンドラインで以下のコマンドを作成することで、Reactのプロジェクトを作成できる
```
$ yarn create vite hello-world --template=react-ts
```
ここではプロジェクトのテンプレートとして`react-ts`を指定することで、
`React`と`TypeScript`を利用するプロジェクトが作成される。 

コマンドが正しく完了すると`hello-world`というディレクトリ名のプロジェクトが作成される。  


# プロジェクト作成後の謎のディレクトリたち
フロントエンドのプロジェクトには、メインロジックやUIとは別のディレクトリやファイルがたくさん登場する。  

例えば以下のようなプロジェクトの場合は、`src`がメインロジックやUIが入る。  
他のディレクトリたちは何のためのものなのか。  
- hello-world/
  - index.html
  - node_modules
  - package.json
  - public
  - src
  - tsconfig.json
  - tsconfig.node.json
  - vite.config.ts
  - yarn.lock

これらは一体なんのためのものなのかを確認していく。  

## node_modules
`node_modules`はプロジェクト内で使用されるパッケージの実行ファイルが置かれるディレクトリである。  


<br>

フロントエンドのプロジェクトを初めて動かす前に、プロジェクトルートで以下のようなコマンドを実行したことがある人も多いのではないだろうか。  
```
npm install
```
```
yarn
```
```
yarn install
```

これらのコマンドは、`package.json`に記述されている依存パッケージを`node_modules`配下にインストールして、  
インストールされたパッケージのバージョン情報を、その依存関係も含めて`package-lock.json`や`yarn.lock`というファイルに出力するというもの。  

そのため実際にフロントエンドのプロジェクトを実行する前には必須のコマンドとなる。  

パッケージマネージャに`npm`をしている場合は`npm install`だし、`yarn`を使用している場合は`yarn`もしくは`yarn install`を実行する。  
ここの`yarn`コマンドは略式表記で、正確には`yarn install`を実行している。  

## package-lock.jsonとyarn.lock
`package-lock`や`yarn.lock`は、`node_modules`にインストールしたパッケージの依存情報を保存しておくためのファイル。

<br>


`node_module`内を確認してもらうとわかる通り、すごい数のディレクトリができているはず。  
前述した通り、これらはプロジェクトで使用するためのパッケージの実行ファイルが格納されており、それらのパッケージは相互に特定のバージョンに依存している。  

そのためちょっとバージョンを変更しただけでアプリケーションが動かなくなる場合がある。  

だからいつ誰がインストールしてもすべてのパッケージで完全に同じバージョンがインストールされるよう、インストールしたパッケージの依存情報を保存しておくためのファイルが`package-lock.json`や`yarn.lock`ファイルである。  

<br>

そのため、Gitリポジトリに`node_modules`は含めないが、`package-lock.json`や`yarn.lock`は必ず入れておくようにする。



## package.json
`package.json`には、プロジェクト内で必要とするパッケージの一覧が記述されている。  


# Hello JavaScript
正式名称は「ECMAScirpt」  
「JavaScript」というのは、元々NetScape社によって開発された`ECMAScript`を、`Mozilla Foundation`が引き継いでいるプロダクトとしての名前である。  
当時流行っていたJavaにあやかってこのような名前となったが、Javaとは全く持って関係の無いプログラミング言語。(マリオブラザーズとスーパーマリオくらい違う)

これまで`ECMAScript`は言語仕様が変更されたため、大きなアップデートが行われるたびに`ES5`や`ES6`のように呼ばれてきたが、  
2015年の`ES6`からエディション名ではなく年号月の仕様署名で呼ぶことが推奨され`ES 2015`と呼ばれるようになった。  
この`ES2015`では大きく言語仕様が改定され、最近のJavaScriptのコーディングはこのときに改定された内容が主流になりつつある。   


JSは登場以前のCやJavaなどのプログラミング言語では馴染みのない概念が多く登場したり、  
初期JSの安全性の低い時期もあったことから「できるだけJSは使いたくない」と言われることが多い。  
しかし近年のアップデートにより、それらはかなりカバーされているためよく好まれる言語の一つでもある。

JavaScriptの特徴
- 第一級関数とクロージャをサポートしている
- 構造体ともクラスインスタンスとも異なる、シンプルで柔軟なオブジェクト
- 表現力の高いリテラル記法

## 第一級関数
関数を値として扱うことができるようになる。  

そのため以下のように、関数の定義を変数に格納して変数を使用して関数を呼び出す事ができるようになる。
```js
const foo = () => {
  console.log("foobar");
}
foo(); // 変数を使用して呼び出し
// foobar
```

## クロージャ
関数内に関数とデータを記述し、データと関数を紐付けることで保守性の高いプログラムを記述する方法。

```js
// 関数の外に設定していた変数はなくなりました

function counter() {
  // 関数内に変数を宣言し用意する
  let count = 0;

  // 関数内にcount変数を利用する関数を定義する
  function returnCounter() {
    count = count + 1;
    console.log(count);
  }

  // リターンとして、returnCounter関数の定義を返す。あくまで『定義』。
  return returnCounter;
}

// counter()を実行して、リターンとしてreturnCounter関数の『定義』を受け取ります。
const myCounter = counter();

// myCounterに()をつけて『returnCounter()』として実行しています。
myCounter();　// 1が出力される
myCounter();　// 2が出力される
myCounter();　// 3が出力される
```

# 変数の宣言
変数の宣言するための構文として`var`が有名だが、今のJSには`const`と`let`が追加され、計以下の３つがある。
- var
- let
- const


|       | 再代入 | 再宣言 |
| ----- | ------ | ------ |
| var   | ○      | ○      |
| let   | ○      | ×      |
| const | ×      | ×      |


しかし従来からある`var`にはいくつかの安全性に欠ける問題があるため、使ってはならない。
- 再宣言および再代入が可能
- 変数の参照が巻き上げられる
- スコープ単位が関数

`const`をメインでどうしようもない場合に`let`を使用することで、安全なプログラミングが可能。

#　JSにおけるデータ型
JavaScriptではJavaと同様、データが以下の２つに大分される。
- プリミティブ型
  - インスタンスメソッドを持たないデータ
- オブジェクト型


## プリミティブ型
JSにおけるプリミティブ型は７種類
- Boolean
  - `true`及び`false`の２つの真偽値を扱うデータ型
- Number
  - 数値を扱うためのデータ型。他の多くの言語と異なり、整数も少数もNumber型になる
- Bigint
  - Numberでは扱いきれない大きな値を扱うためのデータ型。ES2020で追加された。Number型と互換性がなく、相互に代入や計算、当地比較などは行えない。
- String
  - 文字列（テキストを表す連続した文字）扱うためのデータ型
- Symbol   
  - シンボル値という固有の識別子を表現する値。ES2015から追加された。Symbol()関数を呼び出すことで動的に生成されるが、基本的に同じシンボル値をあとから表示できない。オブジェクトのプロパティキーとして使用可能。
- Null  
  - プリミティブ値`null`はなんのデータも存在しない状態を明示的に表す
- Undefined
  - プリミティブ値`undefined`は宣言のみが行われた変数や、オブジェクト内の存在しないプロパティへのアクセスに割り当てられる。他の多くの言語と異なり、`null`と明確に区分される

これらのうち`Bigint`は扱える環境が限定的だったり、`Symbol`はJSONでのパースができなかったりと不便なので活用の場面が無い。  

この内、以下の型がfalseと扱われる。
- false
- 0
- NaN
- ''(空文字)
- null
- undefined

### NaNとは
Number型でありながら、数値ではない（Not a Number）を示す値のこと。  

発生条件は以下の通り
- 0同士の除算
- NaNを含んだ演算
- その他の無効な演算および処理
```
> Math.sqrt(-1)     // -1の平方根
NaN
> Infinity * 0      // 無限大と0の乗算
NaN
> parseInt('foo')   // 数字以外の文字列を数値としてのパース
NaN
```

## プリミティブ値のリテラルとラッパーオブジェクト
プリミティブ型はインスタンスメソッドを持たない。  
しかし以下のようなコードを実行するとメソッドを使うことができる。  
そのためPythonやRubyのようにすべてのデータがオブジェクトなのではないかと思われるかもしれない。
```js
> 'Hello python'.replace("python", "JavaScript")
'Hello JavaScript'
```

しかしそうではない。  
JavaScriptでは、`プリミティブ型の値にアクセスしようとするとき、その対応するラッパーオブジェクトに変換する」という仕様が存在するからである。  

先ほどの例は、内部では以下のように変換されて実行されている。
```js
> new String('Hello python').replace("python", "JavaScript")
'Hello JavaScript'
```

replaceが実行できるのは、プリミティブ型がメソッドを持つのではなく、変換されたStringオブジェクトのインスタンスメソッドを実行していたということ。

## オブジェクト型とそのリテラル
オブジェクトの場合でもリテラルを持つ場合がある。  

- 配列リテラル
  - `[1,2,3]`の形式で記述する。`[]`で空を表す。
- オブジェクトリテラル
  - `{key: value}`の形式で記述する。キーには文字列またはシンボルが用いられる。（数値を利用すると自動的に文字列に変換される）
  - 任意のプロパティにアクセスするには`obj[key]`もしくは`obj.key`でアクセスできる。
  - `Object`オブジェクトのインスタンスとして生成される。
- 正規表現リテラル
  - `patterrn/flags`の形式で記述される。正規表現パターンでの特殊文字の使い方はほぼ共通。`RegExp`オブジェクトのインスタンスとして生成される。

# 関数の定義
JavaScriptでの関数は、文・式のどちらでも定義可能。  

- 式
  - 評価された後に値が返るもの
- 文
  - 手続きを記述し、命令するもの

例えばif文は式ではないため、変数に入れようとすると怒られるが、
```js
> const statement = if (2===2) 'python' else 'javascript';
const statement = if (2===2) 'python' else 'javascript';
                  ^^

Uncaught SyntaxError: Unexpected token 'if'const greet
```

functionは式として扱うことができるので、関数を値として扱うことができる
```js
> const callable = function (n){
... return n*2;
... };
undefined
> callable(2) // 変数callableを関数として扱うことができる
4 
```

関数を文として扱う際は以下の通り。  
```js
function callable(n) {
  return n*2
}
```

JSでは基本的に末尾にセミコロン`;`が必要だが、`{}`ブロックで終わる場合はその限りではない。  
そのため関数式の場合は代入文なので`;`が必要だが、関数文の場合は必要ない。
